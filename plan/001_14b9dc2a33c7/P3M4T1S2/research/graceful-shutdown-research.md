# Graceful Shutdown Research for PRPPipeline

## Overview

This document captures research findings on implementing graceful shutdown handling in Node.js applications, specifically for the PRPPipeline workflow class.

## Node.js Signal Events

### Relevant Signals

- **SIGINT** (Signal Interrupt): Generated by Ctrl+C, typically sent to terminate a process
- **SIGTERM** (Signal Terminate): Generated by the `kill` command, requests process termination

### Standard Exit Codes

- `0` = Success
- `1` = General error
- `130` = 128 + 2 (SIGINT) - Standard exit code for Ctrl+C
- `143` = 128 + 15 (SIGTERM) - Standard exit code for kill command

### Signal Event Handling Pattern

```typescript
process.on('SIGINT', () => {
  log.warn('\nReceived SIGINT, exiting...');
  process.exit(130);
});
```

## Graceful Shutdown Patterns

### Pattern 1: Flag-Based Shutdown

Use a boolean flag to signal shutdown intent:

```typescript
class Workflow {
  shutdownRequested: boolean = false;

  constructor() {
    process.on('SIGINT', () => {
      this.shutdownRequested = true;
    });
  }

  async execute(): Promise<void> {
    while (!this.shutdownRequested && hasMoreWork()) {
      await processNextItem();
    }
    await cleanup();
  }
}
```

**Advantages:**
- Simple to implement
- Current operation completes before exit
- Clean state preservation

**Disadvantages:**
- Requires polling the flag
- May delay shutdown if current operation is long-running

### Pattern 2: Promise-Based Cancellation

Use AbortController for cancellable operations:

```typescript
class Workflow {
  #abortController = new AbortController();

  constructor() {
    process.on('SIGINT', () => {
      this.#abortController.abort();
    });
  }

  async execute(): Promise<void> {
    try {
      await processNextItem({ signal: this.#abortController.signal });
    } catch (error) {
      if (error.name === 'AbortError') {
        await cleanup();
        return;
      }
      throw error;
    }
  }
}
```

**Advantages:**
- Supports cancellation of in-flight operations
- Standard web API pattern
- Better for long-running operations

**Disadvantages:**
- Requires operation support for cancellation signals
- More complex implementation

### Pattern 3: Timeout with Grace Period

Allow force exit after grace period:

```typescript
class Workflow {
  #sigintCount = 0;
  #gracePeriodMs = 5000;

  constructor() {
    process.on('SIGINT', () => {
      this.#sigintCount++;
      if (this.#sigintCount === 1) {
        log.info('Shutting down gracefully... (Ctrl+C again to force exit)');
        this.initiateGracefulShutdown();
        setTimeout(() => {
          if (this.#sigintCount > 1) return;
          log.warn('Grace period expired, forcing exit');
          process.exit(130);
        }, this.#gracePeriodMs);
      } else {
        log.warn('Forcing immediate exit');
        process.exit(130);
      }
    });
  }
}
```

**Advantages:**
- User control over shutdown behavior
- Prevents indefinite hangs
- Clear user feedback

**Disadvantages:**
- More complex state management
- Requires timeout handling

## Implementation in PRPPipeline

### Chosen Pattern: Flag-Based with Duplicate Detection

The PRPPipeline implements a simplified flag-based pattern:

1. **State Tracking**:
   ```typescript
   @ObservedState()
   shutdownRequested: boolean = false;

   @ObservedState()
   shutdownReason: 'SIGINT' | 'SIGTERM' | null = null;
   ```

2. **Signal Handler Registration** (in constructor):
   ```typescript
   #sigintHandler: (() => void) | null = null;
   #sigtermHandler: (() => void) | null = null;
   #sigintCount: number = 0;

   #setupSignalHandlers(): void {
     this.#sigintHandler = () => {
       this.#sigintCount++;
       if (this.#sigintCount > 1) {
         this.logger.warn('Duplicate SIGINT received - shutdown already in progress');
         return;
       }
       this.logger.info('SIGINT received, initiating graceful shutdown');
       this.shutdownRequested = true;
       this.shutdownReason = 'SIGINT';
     };

     this.#sigtermHandler = () => {
       this.logger.info('SIGTERM received, initiating graceful shutdown');
       this.shutdownRequested = true;
       this.shutdownReason = 'SIGTERM';
     };

     process.on('SIGINT', this.#sigintHandler);
     process.on('SIGTERM', this.#sigtermHandler);
   }
   ```

3. **Shutdown Check in Execution Loop**:
   ```typescript
   while (await this.taskOrchestrator.processNextItem()) {
     this.completedTasks = this.#countCompletedTasks();

     if (this.shutdownRequested) {
       this.logger.info('Shutdown requested, finishing current task');
       this.currentPhase = 'shutdown_interrupted';
       break;
     }
   }
   ```

4. **Cleanup in Finally Block**:
   ```typescript
   async run(): Promise<PipelineResult> {
     try {
       await this.initializeSession();
       await this.decomposePRD();
       await this.executeBacklog();
       await this.runQACycle();
     } finally {
       await this.cleanup(); // Always runs
     }
   }

   @Step({ trackTiming: true })
   async cleanup(): Promise<void> {
     const backlog = this.sessionManager.currentSession?.taskRegistry;
     if (backlog) {
       await this.sessionManager.saveBacklog(backlog);
     }

     // Remove signal listeners
     if (this.#sigintHandler) {
       process.off('SIGINT', this.#sigintHandler);
     }
     if (this.#sigtermHandler) {
       process.off('SIGTERM', this.#sigtermHandler);
     }

     this.currentPhase = 'shutdown_complete';
   }
   ```

## Key Gotchas Discovered

### 1. Signal Listener Memory Leaks

**Issue**: Signal listeners accumulate if not removed.

**Solution**: Store handler references and remove in cleanup:
```typescript
#sigintHandler: (() => void) | null = null;

#setupSignalHandlers(): void {
  this.#sigintHandler = () => { /* ... */ };
  process.on('SIGINT', this.#sigintHandler);
}

async cleanup(): Promise<void> {
  if (this.#sigintHandler) {
    process.off('SIGINT', this.#sigintHandler);
  }
}
```

### 2. Handler Reference Loss

**Issue**: Inline arrow functions can't be removed.

**Wrong:**
```typescript
process.on('SIGINT', () => { /* ... */ }); // Can't remove this!
process.off('SIGINT', () => { /* ... */ }); // Different reference
```

**Correct:**
```typescript
this.#sigintHandler = () => { /* ... */ };
process.on('SIGINT', this.#sigintHandler);
process.off('SIGINT', this.#sigintHandler); // Same reference
```

### 3. Shutdown Check Timing

**Issue**: Checking shutdown flag before operation starts prevents current task from completing.

**Wrong:**
```typescript
while (!this.shutdownRequested && hasMoreWork()) {
  await processNextItem(); // Might be interrupted mid-task
}
```

**Correct:**
```typescript
while (await processNextItem()) {
  if (this.shutdownRequested) break; // Let task complete first
}
```

### 4. Cleanup Must Always Run

**Issue**: Errors during execution can skip cleanup.

**Wrong:**
```typescript
await this.executeBacklog();
await this.cleanup(); // Never runs if executeBacklog throws
```

**Correct:**
```typescript
try {
  await this.executeBacklog();
} finally {
  await this.cleanup(); // Always runs
}
```

### 5. SessionManager Creation in run()

**Issue**: When `run()` creates a new SessionManager, tests can't inject mocks.

**Solution**: Mock the SessionManager class at module level:
```typescript
vi.mock('../../../src/core/session-manager.js', () => ({
  SessionManager: vi.fn().mockImplementation(() => mockObject),
}));
```

## References

- [Node.js Process Signal Events](https://nodejs.org/api/process.html#process_signal_events)
- [Node.js Process Exit Codes](https://nodejs.org/api/process.html#process_exit_codes)
- [Graceful Termination Reference](https://github.com/gajus/graceful-termination#readme)
- [TypeScript Decorators](https://www.typescriptlang.org/docs/handshell/decorators.html)

## Future Enhancements

1. **Force Exit on Double SIGINT**: Currently logs warning, could implement immediate exit
2. **AbortController Integration**: For cancellable subtask operations
3. **Grace Period Timeout**: Auto-force exit after timeout period
4. **Progress Persistence During Execution**: Save state after each task completion
5. **Shutdown Hook API**: Allow custom shutdown logic from external callers
