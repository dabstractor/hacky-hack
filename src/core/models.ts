/**
 * Type definitions for task hierarchy models
 *
 * @module core/models
 *
 * @remarks
 * Defines the four-level task hierarchy used throughout the PRP Pipeline:
 * Phase > Milestone > Task > Subtask. All types use readonly properties
 * to ensure immutability and prevent accidental state mutation.
 *
 * @example
 * ```typescript
 * import { Backlog, Status } from './core/models.js';
 *
 * const backlog: Backlog = {
 *   backlog: [
 *     {
 *       id: 'P1',
 *       type: 'Phase',
 *       title: 'Phase 1: Foundation',
 *       status: 'Planned',
 *       description: 'Project initialization',
 *       milestones: []
 *     }
 *   ]
 * };
 * ```
 */

import { z } from 'zod';

/**
 * Lifecycle status of a work item in the PRP Pipeline
 *
 * @remarks
 * Each work item progresses through these states as it moves from
 * conception to completion. The Architect Agent creates items in
 * 'Planned' status, and the Task Orchestrator updates status as
 * work progresses.
 *
 * - `Planned`: Initial state after Architect Agent generates the backlog
 * - `Researching`: Research Agent is gathering context for PRP generation
 * - `Implementing`: Coder Agent is actively implementing the PRP
 * - `Complete`: All validation gates passed, work is done
 * - `Failed`: Implementation failed, requires retry or manual intervention
 * - `Obsolete`: Work item was deprecated or replaced (e.g., delta session)
 *
 * @example
 * ```typescript
 * import { Status } from './core/models.js';
 *
 * const currentStatus: Status = 'Implementing';
 * ```
 */
export type Status =
  | 'Planned'
  | 'Researching'
  | 'Implementing'
  | 'Complete'
  | 'Failed'
  | 'Obsolete';

/**
 * Zod schema for Status enum validation
 *
 * @remarks
 * Validates that a value is one of the valid Status values.
 * Use this for runtime validation of status fields.
 *
 * @example
 * ```typescript
 * import { StatusEnum } from './core/models.js';
 *
 * const result = StatusEnum.safeParse('Planned');
 * // result.success === true
 * ```
 */
export const StatusEnum = z.enum([
  'Planned',
  'Researching',
  'Implementing',
  'Complete',
  'Failed',
  'Obsolete',
]);

/**
 * Type discriminator for the four levels of task hierarchy
 *
 * @remarks
 * Each work item has a `type` field that indicates its level in the
 * hierarchy. This enables type narrowing when processing heterogeneous
 * collections of work items.
 *
 * @example
 * ```typescript
 * import { ItemType } from './core/models.js';
 *
 * const type: ItemType = 'Subtask';
 * ```
 */
export type ItemType = 'Phase' | 'Milestone' | 'Task' | 'Subtask';

/**
 * Zod schema for ItemType enum validation
 *
 * @remarks
 * Validates that a value is one of the valid ItemType values.
 * Use this for runtime validation of type fields.
 *
 * @example
 * ```typescript
 * import { ItemTypeEnum } from './core/models.js';
 *
 * const result = ItemTypeEnum.safeParse('Subtask');
 * // result.success === true
 * ```
 */
export const ItemTypeEnum = z.enum(['Phase', 'Milestone', 'Task', 'Subtask']);

/**
 * Leaf node in the task hierarchy - the smallest unit of work
 *
 * @remarks
 * Subtasks represent atomic work items that can be completed in a single
 * implementation pass. Each subtask has a PRP (Product Requirement Prompt)
 * generated by the Researcher Agent and executed by the Coder Agent.
 *
 * The `context_scope` field contains critical instructions for the Coder Agent,
 * defining what code it can access and modify during implementation.
 *
 * @see {@link https://github.com/anthropics/claude-code/blob/main/PRP-TEMPLATE.md | PRP Template}
 *
 * @example
 * ```typescript
 * import { Subtask, Status } from './core/models.js';
 *
 * const subtask: Subtask = {
 *   id: 'P1.M1.T1.S1',
 *   type: 'Subtask',
 *   title: 'Create TypeScript interfaces for task hierarchy',
 *   status: 'Planned',
 *   story_points: 2,
 *   dependencies: [],
 *   context_scope: 'Strict scope: src/core/ directory only'
 * };
 * ```
 */
export interface Subtask {
  /**
   * Unique identifier following dot-notation hierarchy
   *
   * @format P{phase}.M{milestone}.T{task}.S{subtask}
   * @example 'P1.M1.T1.S1'
   */
  readonly id: string;

  /** Type discriminator for type narrowing */
  readonly type: 'Subtask';

  /**
   * Human-readable title of the work item
   *
   * @minLength 1
   * @maxLength 200
   */
  readonly title: string;

  /** Current lifecycle status */
  readonly status: Status;

  /**
   * Estimated complexity in Fibonacci story points
   *
   * @remarks
   * Uses the Fibonacci sequence: 1, 2, 3, 5, 8, 13, 21
   * Larger values indicate higher uncertainty and complexity
   *
   * @min 1
   * @max 21
   */
  readonly story_points: number;

  /**
   * IDs of subtasks that must complete before this one can start
   *
   * @remarks
   * The Task Orchestrator uses this array to enforce dependency ordering.
   * Empty array means no dependencies.
   *
   * @example ['P1.M1.T1.S1', 'P1.M1.T1.S2']
   */
  readonly dependencies: string[];

  /**
   * Strict instructions for isolated development
   *
   * @remarks
   * Defines INPUT (what to use), OUTPUT (what to produce), and MOCKING
   * (what external services to fake). This context is injected into the
   * Coder Agent's prompt.
   *
   * @example
   * ```
   * INPUT: TaskRegistry from dependency P1.M2.T1.S1
   * OUTPUT: TaskService.create() method
   * MOCKING: Groundswell agents, file system operations
   * ```
   */
  readonly context_scope: string;
}

/**
 * Zod schema for Subtask validation
 *
 * @remarks
 * Validates Subtask objects with all field constraints including story points
 * range (Fibonacci: 1-21) and ID format validation.
 *
 * @example
 * ```typescript
 * import { SubtaskSchema } from './core/models.js';
 *
 * const result = SubtaskSchema.safeParse({
 *   id: 'P1.M1.T1.S1',
 *   type: 'Subtask',
 *   title: 'Create Zod schemas',
 *   status: 'Planned',
 *   story_points: 2,
 *   dependencies: [],
 *   context_scope: 'src/core/models.ts only'
 * });
 * // result.success === true
 * ```
 */
export const SubtaskSchema: z.ZodType<Subtask> = z.object({
  id: z
    .string()
    .regex(
      /^P\d+\.M\d+\.T\d+\.S\d+$/,
      'Invalid subtask ID format (expected P{N}.M{N}.T{N}.S{N})'
    ),
  type: z.literal('Subtask'),
  title: z.string().min(1, 'Title is required').max(200, 'Title too long'),
  status: StatusEnum,
  story_points: z
    .number({ invalid_type_error: 'Story points must be a number' })
    .int('Story points must be an integer')
    .min(1, 'Story points must be at least 1')
    .max(21, 'Story points cannot exceed 21'),
  dependencies: z.array(z.string()).min(0),
  context_scope: z.string().min(1, 'Context scope is required'),
});

/**
 * Container for related subtasks forming a coherent unit of work
 *
 * @remarks
 * Tasks represent intermediate-level work items that group related subtasks.
 * A Task is typically completed when all its subtasks are Complete.
 *
 * @example
 * ```typescript
 * import { Task, Status } from './core/models.js';
 *
 * const task: Task = {
 *   id: 'P1.M1.T1',
 *   type: 'Task',
 *   title: 'Initialize TypeScript Project',
 *   status: 'Planned',
 *   description: 'Set up package.json, tsconfig.json, and directory structure',
 *   subtasks: [
 *     {
 *       id: 'P1.M1.T1.S1',
 *       type: 'Subtask',
 *       title: 'Initialize package.json',
 *       status: 'Complete',
 *       story_points: 1,
 *       dependencies: [],
 *       context_scope: '...'
 *     }
 *   ]
 * };
 * ```
 */
export interface Task {
  /**
   * Unique identifier following dot-notation hierarchy
   *
   * @format P{phase}.M{milestone}.T{task}
   * @example 'P1.M1.T1'
   */
  readonly id: string;

  /** Type discriminator for type narrowing */
  readonly type: 'Task';

  /** Human-readable title of the work item */
  readonly title: string;

  /** Current lifecycle status */
  readonly status: Status;

  /**
   * Detailed description of the task's objectives
   *
   * @remarks
   * Explains what the task accomplishes and how its subtasks
   * contribute to the overall goal.
   */
  readonly description: string;

  /**
   * Array of subtasks that comprise this task
   *
   * @remarks
   * Tasks contain subtasks, forming a parent-child relationship.
   * The Task Orchestrator processes subtasks sequentially based on
   * dependency ordering within this array.
   */
  readonly subtasks: Subtask[];
}

/**
 * Zod schema for Task validation
 *
 * @remarks
 * Validates Task objects with recursive Subtask array validation.
 * Note that Tasks contain Subtasks, not other Tasks.
 *
 * @example
 * ```typescript
 * import { TaskSchema } from './core/models.js';
 *
 * const result = TaskSchema.safeParse({
 *   id: 'P1.M1.T1',
 *   type: 'Task',
 *   title: 'Define Task Models',
 *   status: 'Planned',
 *   description: 'Create TypeScript interfaces',
 *   subtasks: []
 * });
 * // result.success === true
 * ```
 */
export const TaskSchema: z.ZodType<Task> = z.object({
  id: z
    .string()
    .regex(
      /^P\d+\.M\d+\.T\d+$/,
      'Invalid task ID format (expected P{N}.M{N}.T{N})'
    ),
  type: z.literal('Task'),
  title: z.string().min(1, 'Title is required').max(200, 'Title too long'),
  status: StatusEnum,
  description: z.string().min(1, 'Description is required'),
  subtasks: z.array(SubtaskSchema),
});

/**
 * Significant checkpoint or deliverable within a phase
 *
 * @remarks
 * Milestones represent major progress points that group related tasks.
 * They often correspond to deliverable increments or validation gates.
 *
 * @example
 * ```typescript
 * import { Milestone, Status } from './core/models.js';
 *
 * const milestone: Milestone = {
 *   id: 'P1.M1',
 *   type: 'Milestone',
 *   title: 'Project Initialization',
 *   status: 'Complete',
 *   description: 'Foundation setup and environment configuration',
 *   tasks: []
 * };
 * ```
 */
export interface Milestone {
  /**
   * Unique identifier following dot-notation hierarchy
   *
   * @format P{phase}.M{milestone}
   * @example 'P1.M1'
   */
  readonly id: string;

  /** Type discriminator for type narrowing */
  readonly type: 'Milestone';

  /** Human-readable title of the work item */
  readonly title: string;

  /** Current lifecycle status */
  readonly status: Status;

  /**
   * Detailed description of the milestone's objectives
   *
   * @remarks
   * Explains what the milestone accomplishes and what deliverables
   * are expected upon completion.
   */
  readonly description: string;

  /**
   * Array of tasks that comprise this milestone
   *
   * @remarks
   * Milestones contain tasks, forming a parent-child relationship.
   * Tasks are processed based on their internal dependencies.
   */
  readonly tasks: Task[];
}

/**
 * Zod schema for Milestone validation
 *
 * @remarks
 * Validates Milestone objects with recursive Task array validation.
 * Uses z.lazy() to handle the recursive reference to TaskSchema.
 *
 * @example
 * ```typescript
 * import { MilestoneSchema } from './core/models.js';
 *
 * const result = MilestoneSchema.safeParse({
 *   id: 'P1.M1',
 *   type: 'Milestone',
 *   title: 'Project Initialization',
 *   status: 'Complete',
 *   description: 'Foundation setup and environment configuration',
 *   tasks: []
 * });
 * // result.success === true
 * ```
 */
export const MilestoneSchema: z.ZodType<Milestone> = z.lazy(() =>
  z.object({
    id: z
      .string()
      .regex(
        /^P\d+\.M\d+$/,
        'Invalid milestone ID format (expected P{N}.M{N})'
      ),
    type: z.literal('Milestone'),
    title: z.string().min(1, 'Title is required').max(200, 'Title too long'),
    status: StatusEnum,
    description: z.string().min(1, 'Description is required'),
    tasks: z.array(z.lazy(() => TaskSchema)),
  })
);

/**
 * Top-level container representing a major development phase
 *
 * @remarks
 * Phases represent the highest level of organization in the PRP Pipeline.
 * Each phase typically corresponds to a major capability or milestone
 * in the overall product roadmap (e.g., "Foundation", "Core Agent System").
 *
 * @example
 * ```typescript
 * import { Phase, Status } from './core/models.js';
 *
 * const phase: Phase = {
 *   id: 'P1',
 *   type: 'Phase',
 *   title: 'Phase 1: Foundation & Environment Setup',
 *   status: 'Complete',
 *   description: 'Project initialization, environment configuration, and core data structures',
 *   milestones: []
 * };
 * ```
 */
export interface Phase {
  /**
   * Unique identifier for the phase
   *
   * @format P{phase}
   * @example 'P1'
   */
  readonly id: string;

  /** Type discriminator for type narrowing */
  readonly type: 'Phase';

  /** Human-readable title of the work item */
  readonly title: string;

  /** Current lifecycle status */
  readonly status: Status;

  /**
   * Detailed description of the phase's objectives
   *
   * @remarks
   * Explains the overall goals, scope, and expected outcomes
   * for this phase of development.
   */
  readonly description: string;

  /**
   * Array of milestones that comprise this phase
   *
   * @remarks
   * Phases contain milestones, forming the top level of the hierarchy.
   * The PRP Pipeline processes phases sequentially.
   */
  readonly milestones: Milestone[];
}

/**
 * Zod schema for Phase validation
 *
 * @remarks
 * Validates Phase objects with recursive Milestone array validation.
 * Uses z.lazy() to handle the recursive reference to MilestoneSchema.
 *
 * @example
 * ```typescript
 * import { PhaseSchema } from './core/models.js';
 *
 * const result = PhaseSchema.safeParse({
 *   id: 'P1',
 *   type: 'Phase',
 *   title: 'Phase 1: Foundation',
 *   status: 'Planned',
 *   description: 'Project initialization',
 *   milestones: []
 * });
 * // result.success === true
 * ```
 */
export const PhaseSchema: z.ZodType<Phase> = z.lazy(() =>
  z.object({
    id: z.string().regex(/^P\d+$/, 'Invalid phase ID format (expected P{N})'),
    type: z.literal('Phase'),
    title: z.string().min(1, 'Title is required').max(200, 'Title too long'),
    status: StatusEnum,
    description: z.string().min(1, 'Description is required'),
    milestones: z.array(z.lazy(() => MilestoneSchema)),
  })
);

/**
 * Root container for the entire task backlog
 *
 * @remarks
 * The Backlog interface represents the top-level structure stored in
 * `tasks.json`. It contains an array of Phases, forming the complete
 * hierarchy of work for the PRP Pipeline.
 *
 * The Session Manager loads this structure, and the Task Orchestrator
 * iterates through it to execute work items.
 *
 * @see {@link ./architecture/system_context.md#task-hierarchy-json-schema | System Context}
 *
 * @example
 * ```typescript
 * import { Backlog, Phase } from './core/models.js';
 *
 * const backlog: Backlog = {
 *   backlog: [
 *     {
 *       id: 'P1',
 *       type: 'Phase',
 *       title: 'Phase 1: Foundation',
 *       status: 'Planned',
 *       description: 'Project setup and core data structures',
 *       milestones: []
 *     },
 *     {
 *       id: 'P2',
 *       type: 'Phase',
 *       title: 'Phase 2: Core Agent System',
 *       status: 'Planned',
 *       description: 'Groundswell agent integration and prompt system',
 *       milestones: []
 *     }
 *   ]
 * };
 * ```
 */
export interface Backlog {
  /**
   * Array of phases comprising the complete project backlog
   *
   * @remarks
   * This is the root of the task hierarchy. All phases, milestones,
   * tasks, and subtasks are contained within this array.
   *
   * The Task Orchestrator processes phases sequentially in order,
   * then recursively processes nested items.
   */
  readonly backlog: Phase[];
}

/**
 * Zod schema for Backlog validation
 *
 * @remarks
 * Validates Backlog objects containing an array of Phase objects.
 * This is the root schema for the entire task hierarchy.
 *
 * @example
 * ```typescript
 * import { BacklogSchema } from './core/models.js';
 *
 * const result = BacklogSchema.safeParse({
 *   backlog: [
 *     {
 *       id: 'P1',
 *       type: 'Phase',
 *       title: 'Phase 1: Foundation',
 *       status: 'Planned',
 *       description: 'Project setup',
 *       milestones: []
 *     }
 *   ]
 * });
 * // result.success === true
 * ```
 */
export const BacklogSchema: z.ZodType<Backlog> = z.object({
  backlog: z.array(PhaseSchema),
});

/**
 * Session Metadata Interface
 *
 * Identifies and locates a session in the filesystem. Sessions are
 * created when the PRP Pipeline initializes, providing an immutable
 * audit trail of development history.
 *
 * @remarks
 * Session identifiers use the format `{sequence}_{hash}` where:
 * - `sequence`: Zero-padded incremental number (001, 002, 003, ...)
 * - `hash`: First 12 characters of the PRD content hash (SHA-256)
 *
 * The session directory path is `plan/{sequence}_{hash}/`.
 *
 * Delta sessions set `parentSession` to the parent session ID, enabling
 * change tracking and selective re-execution of modified tasks.
 *
 * @see {@link ../../plan/001_14b9dc2a33c7/architecture/system_context.md | System Context: Session Directory Structure}
 *
 * @example
 * ```typescript
 * import { SessionMetadata } from './core/models.js';
 *
 * const metadata: SessionMetadata = {
 *   id: '001_14b9dc2a33c7',
 *   hash: '14b9dc2a33c7',
 *   path: 'plan/001_14b9dc2a33c7',
 *   createdAt: new Date('2024-01-12T10:00:00Z'),
 *   parentSession: null  // Initial session has no parent
 * };
 * ```
 */
export interface SessionMetadata {
  /**
   * Unique session identifier combining sequence and PRD hash
   *
   * @format {sequence}_{hash}
   * @example '001_14b9dc2a33c7'
   */
  readonly id: string;

  /**
   * SHA-256 hash of the PRD content (first 12 characters)
   *
   * @remarks
   * Used for PRD change detection. If the hash differs from the
   * current PRD hash, a delta session is required.
   *
   * @length 12
   */
  readonly hash: string;

  /**
   * Filesystem path to the session directory
   *
   * @format plan/{sequence}_{hash}/
   * @example 'plan/001_14b9dc2a33c7/'
   */
  readonly path: string;

  /**
   * Timestamp when the session was created
   *
   * @remarks
   * Stored as a Date object for type safety. Serialized to ISO 8601
   * format when persisted to JSON.
   *
   * @format ISO 8601
   */
  readonly createdAt: Date;

  /**
   * Parent session ID for delta sessions
   *
   * @remarks
   * Null for initial sessions. Set to the parent session ID for
   * delta sessions created when the PRD is modified.
   *
   * This enables the Session Manager to trace the lineage of sessions
   * and determine which tasks can be reused from the parent session.
   *
   * @nullable true
   * @example '001_14b9dc2a33c7' for a delta session, null for initial session
   */
  readonly parentSession: string | null;
}

/**
 * Complete state of a development session
 *
 * @remarks
 * SessionState captures the complete state at session initialization,
 * including the PRD snapshot, task hierarchy, and current execution
 * position. This state is persisted to `tasks.json` and loaded by
 * the Session Manager to enable resume capability.
 *
 * The `currentItemId` field tracks which task/subtask is currently
 * being executed, enabling the pipeline to resume from interruption
 * without re-executing completed work.
 *
 * @see {@link ../../plan/001_14b9dc2a33c7/architecture/system_context.md | System Context: Task Hierarchy}
 *
 * @example
 * ```typescript
 * import { SessionState, SessionMetadata, Backlog, Status } from './core/models.js';
 *
 * const state: SessionState = {
 *   metadata: {
 *     id: '001_14b9dc2a33c7',
 *     hash: '14b9dc2a33c7',
 *     path: 'plan/001_14b9dc2a33c7',
 *     createdAt: new Date(),
 *     parentSession: null
 *   },
 *   prdSnapshot: '# PRD Content\\n...',
 *   taskRegistry: {
 *     backlog: [
 *       {
 *         id: 'P1',
 *         type: 'Phase',
 *         title: 'Phase 1',
 *         status: 'Planned',
 *         description: 'Foundation',
 *         milestones: []
 *       }
 *     ]
 *   },
 *   currentItemId: 'P1.M1.T1.S1'
 * };
 * ```
 */
export interface SessionState {
  /** Session identification and filesystem location */
  readonly metadata: SessionMetadata;

  /**
   * Full PRD content at session initialization
   *
   * @remarks
   * Stores the complete PRD markdown content as a string. Used for
   * change detection and as the baseline for delta diffing.
   *
   * The PRD snapshot is stored in `plan/{session_id}/prd_snapshot.md`
   * and this field contains its content as a string for easy access.
   */
  readonly prdSnapshot: string;

  /**
   * Task hierarchy for this session
   *
   * @remarks
   * Reuses the existing `Backlog` interface from the task hierarchy.
   * Contains the complete Phase > Milestone > Task > Subtask structure
   * generated by the Architect Agent.
   *
   * This registry is the single source of truth for task execution.
   * Status updates are persisted here as work progresses.
   */
  readonly taskRegistry: Backlog;

  /**
   * Currently executing work item ID
   *
   * @remarks
   * Tracks the task/subtask currently being executed by the pipeline.
   * Null if no task is currently active (e.g., session initialized
   * but execution not started, or all tasks complete).
   *
   * Enables resume capability: the Task Orchestrator can find and
   * continue from this item after interruption.
   *
   * @format P{phase}.M{milestone}.T{task}.S{subtask} or similar
   * @nullable true
   * @example 'P1.M1.T1.S1' for a subtask, null when idle
   */
  readonly currentItemId: string | null;
}

/**
 * Delta session state for PRD change management
 *
 * @remarks
 * Delta sessions are created when the master PRD is modified after
 * initial session creation. They extend the base SessionState with
 * additional fields for PRD diffing and change analysis.
 *
 * The Delta Analysis workflow (P4.M1.T1) compares oldPRD and newPRD
 * to generate the diffSummary, which guides task patching logic.
 *
 * Delta sessions reference their parent session via the inherited
 * `parentSession` field in metadata, enabling the pipeline to reuse
 * completed work from the parent session.
 *
 * @see {@link ../../../PRD.md#43-the-delta-workflow-change-management | PRD: Delta Workflow}
 *
 * @example
 * ```typescript
 * import { DeltaSession, SessionMetadata, Backlog } from './core/models.js';
 *
 * const delta: DeltaSession = {
 *   metadata: {
 *     id: '002_a3f8e9d12b4',
 *     hash: 'a3f8e9d12b4',
 *     path: 'plan/002_a3f8e9d12b4',
 *     createdAt: new Date(),
 *     parentSession: '001_14b9dc2a33c7'  // References parent session
 *   },
 *   prdSnapshot: '# Updated PRD\\n...',
 *   taskRegistry: { backlog: [] },
 *   currentItemId: null,
 *   oldPRD: '# Original PRD\\n...',
 *   newPRD: '# Updated PRD\\n...',
 *   diffSummary: 'Added new feature X, modified feature Y requirements'
 * };
 * ```
 */
export interface DeltaSession extends SessionState {
  /**
   * Original PRD content before modification
   *
   * @remarks
   * Stores the PRD content from the parent session. Used by the
   * Delta Analysis workflow to compute differences and identify
   * which tasks are affected by PRD changes.
   */
  readonly oldPRD: string;

  /**
   * Modified PRD content after user changes
   *
   * @remarks
   * The updated PRD that triggered delta session creation. The
   * Architect Agent will process this PRD to generate an updated
   * task registry.
   */
  readonly newPRD: string;

  /**
   * Human-readable summary of PRD differences
   *
   * @remarks
   * Generated by the Delta Analysis workflow (P4.M1.T1). Provides
   * a high-level description of what changed in the PRD, which
   * guides task patching decisions.
   *
   * Example content: "Added Phase 5 for production deployment,
   * modified P3.M2.T1 to include parallel research, removed
   * deprecated P2.M3.T2.S1"
   */
  readonly diffSummary: string;
}
